{"version":3,"file":"ecdsa-secp256k1-verification-key-2019.cjs.production.min.js","sources":["../src/verificationKey.ts","../src/keyUtils.ts"],"sourcesContent":["// @ts-nocheck\nimport base64url from 'base64url'\nimport createHash from 'create-hash'\nimport * as secp256k1 from 'secp256k1'\nimport randomBytes from 'randombytes'\n// @ts-expect-error: implicit type import; not a ts package\nimport cryptoLd from 'crypto-ld'\n// @ts-expect-error: implicit type import; not a ts package\nimport * as base58 from 'base58-universal'\n\nconst SUITE_ID = 'EcdsaSecp256k1VerificationKey2019'\n\nconst sha256 = (data: any) => createHash('sha256').update(data).digest()\n\ntype ExportedKey = {\n  '@context'?: string\n  type: string\n  id: string\n  controller: string\n  publicKeyBase58?: string\n  privateKeyBase58?: string\n  revoked?: boolean\n}\n\ntype EcdsaSecp256k1VerificationKey2019Options = {\n  controller: string\n  id: string\n  revoked?: boolean\n  publicKeyBase58?: string\n  privateKeyBase58?: string\n}\n\ntype EcdsaSecp256k1VerificationKey2019HexKeyOptions = {\n  controller: string\n  id: string\n  revoked?: boolean\n  publicKeyHex?: string\n  privateKeyHex?: string\n}\n\nexport class EcdsaSecp256k1VerificationKey2019 extends cryptoLd.LDKeyPair {\n  public type: string\n\n  public publicKeyBase58?: string\n\n  public privateKeyBase58?: string\n\n  constructor({ publicKeyBase58, privateKeyBase58, ...options }: EcdsaSecp256k1VerificationKey2019Options) {\n    super(options)\n\n    if (privateKeyBase58 && !publicKeyBase58) {\n      const publicKey = secp256k1.publicKeyCreate(base58.decode(privateKeyBase58))\n      this.publicKeyBase58 = base58.encode(publicKey)\n    } else {\n      this.publicKeyBase58 = publicKeyBase58\n    }\n\n    this.type = SUITE_ID\n    this.privateKeyBase58 = privateKeyBase58\n\n    if (!this.publicKeyBase58) {\n      throw new TypeError('The \"publicKeyBase58\" property is required.')\n    }\n  }\n\n  static from(options: EcdsaSecp256k1VerificationKey2019Options | EcdsaSecp256k1VerificationKey2019HexKeyOptions) {\n    if ((options as any).publicKeyHex || (options as any).privateKeyHex) {\n      const { publicKeyHex, privateKeyHex, ...rest } = options as any\n\n      return new EcdsaSecp256k1VerificationKey2019({\n        ...rest,\n        publicKeyBase58: publicKeyHex ? base58.encode(Buffer.from(publicKeyHex, 'hex')) : undefined,\n        privateKeyBase58: privateKeyHex ? base58.encode(Buffer.from(privateKeyHex, 'hex')) : undefined,\n      })\n    }\n\n    return new EcdsaSecp256k1VerificationKey2019(options)\n  }\n\n  static async generate({\n    seed,\n    compressed,\n    ...keyPairOptions\n  }: Omit<EcdsaSecp256k1VerificationKey2019Options, 'publicKeyBase58' | 'privateKeyBase58'> & { seed?: Uint8Array; compressed?: boolean }) {\n    if (seed && !secp256k1.privateKeyVerify(seed)) {\n      throw new Error('Provided seed is not a valid private key')\n    }\n\n    let privateKey = seed\n\n    while (typeof privateKey === 'undefined' || !secp256k1.privateKeyVerify(privateKey)) {\n      privateKey = new Uint8Array(randomBytes(32))\n    }\n\n    const publicKey = secp256k1.publicKeyCreate(privateKey, compressed)\n\n    return new EcdsaSecp256k1VerificationKey2019({\n      publicKeyBase58: base58.encode(publicKey),\n      privateKeyBase58: base58.encode(privateKey),\n      ...keyPairOptions,\n    })\n  }\n\n  export({\n    publicKey = false,\n    privateKey = false,\n    includeContext = false,\n  }: {\n    publicKey?: boolean\n    privateKey?: boolean\n    includeContext?: boolean\n  } = {}): ExportedKey {\n    if (!(publicKey || privateKey)) {\n      throw new TypeError('export requires specifying either \"publicKey\" or \"privateKey\".')\n    }\n\n    if (privateKey && !this.privateKeyBase58) {\n      throw new TypeError('No privateKey to export.')\n    }\n\n    if (publicKey && !this.publicKeyBase58) {\n      throw new TypeError('No publicKey to export.')\n    }\n\n    const exported: ExportedKey = {\n      type: this.type,\n      id: this.id,\n      controller: this.controller,\n      revoked: this.revoked,\n    }\n\n    if (includeContext) {\n      exported['@context'] = EcdsaSecp256k1VerificationKey2019.SUITE_CONTEXT\n    }\n    if (privateKey) exported.privateKeyBase58 = this.privateKeyBase58\n    if (publicKey) exported.publicKeyBase58 = this.publicKeyBase58\n\n    return exported\n  }\n\n  signer() {\n    const { privateKeyBase58 } = this\n\n    if (!privateKeyBase58) {\n      return {\n        async sign() {\n          throw new Error('No private key to sign with.')\n        },\n        id: this.id,\n      }\n    }\n\n    return {\n      async sign({ data }: { data: Uint8Array }) {\n        const encodedHeader = base64url.encode(\n          JSON.stringify({\n            alg: 'ES256K',\n            b64: false,\n            crit: ['b64'],\n          }),\n        )\n\n        const payload = Buffer.from(data.buffer, data.byteOffset, data.length)\n        const digest = sha256(\n          Buffer.from(\n            Buffer.concat([Buffer.from(`${encodedHeader}.`, 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]),\n          ),\n        )\n\n        const { signature } = secp256k1.ecdsaSign(digest, base58.decode(privateKeyBase58))\n        const encodedSignature = base64url.encode(Buffer.from(signature))\n\n        return `${encodedHeader}..${encodedSignature}`\n      },\n      id: this.id,\n    }\n  }\n\n  verifier() {\n    const { publicKeyBase58 } = this\n\n    if (!publicKeyBase58) {\n      return {\n        async verify() {\n          throw new Error('No public key to verify against')\n        },\n        id: this.id,\n      }\n    }\n\n    return {\n      async verify({ data, signature }: { data: Uint8Array; signature: string }) {\n        if (signature.indexOf('..') < 0) return false\n\n        const [encodedHeader, encodedSignature] = signature.split('..')\n        const header = JSON.parse(base64url.decode(encodedHeader))\n        const isHeaderInvalid =\n          header.alg !== 'ES256K' || header.b64 !== false || !header.crit || !header.crit.length || header.crit[0] !== 'b64'\n\n        if (isHeaderInvalid) return false\n\n        const payload = Buffer.from(data.buffer, data.byteOffset, data.length)\n        const digest = sha256(\n          Buffer.from(\n            Buffer.concat([Buffer.from(`${encodedHeader}.`, 'utf8'), Buffer.from(payload.buffer, payload.byteOffset, payload.length)]),\n          ),\n        )\n\n        let verified: boolean\n        try {\n          verified = secp256k1.ecdsaVerify(\n            Buffer.from(base64url.decode(encodedSignature, 'hex'), 'hex'),\n            digest,\n            base58.decode(publicKeyBase58),\n          )\n        } catch {\n          verified = false\n        }\n\n        return verified\n      },\n      id: this.id,\n    }\n  }\n}\n\nEcdsaSecp256k1VerificationKey2019.suite = SUITE_ID\nEcdsaSecp256k1VerificationKey2019.SUITE_CONTEXT = 'https://ns.did.ai/suites/secp256k1-2019/v1'\n","import secp256k1 from 'secp256k1'\n// @ts-expect-error: implicit type import; not a ts package\nimport keyto from '@trust/keyto'\n// @ts-expect-error: implicit type import; not a ts package\nimport * as base58 from 'base58-universal'\n\nconst compressedHexEncodedPublicKeyLength = 66\n\nexport type PrivateKeyJWK = {\n  kty: string\n  crv: string\n  d: string\n  x: string\n  y: string\n  kid: string\n}\n\nexport type PublicKeyJWK = {\n  kty: string\n  crv: string\n  x: string\n  y: string\n  kid: string\n}\n\nexport const publicKeyHexFrom = {\n  publicKeyBase58: (publicKeyBase58: string): string => Buffer.from(base58.decode(publicKeyBase58)).toString('hex'),\n  publicKeyJWK: (jwk: PublicKeyJWK): string =>\n    Buffer.from(\n      secp256k1.publicKeyConvert(\n        Buffer.from(\n          keyto\n            .from(\n              {\n                ...jwk,\n                crv: 'K-256',\n              },\n              'jwk',\n            )\n            .toString('blk', 'public'),\n          'hex',\n        ),\n        true,\n      ),\n    ).toString('hex'),\n  publicKeyUint8Array: (publicKeyUint8Array: Uint8Array): string => Buffer.from(publicKeyUint8Array).toString('hex'),\n  privateKeyHex: (privateKeyHex: string): string =>\n    Buffer.from(secp256k1.publicKeyCreate(new Uint8Array(Buffer.from(privateKeyHex, 'hex')))).toString('hex'),\n}\n\nexport const privateKeyHexFrom = {\n  privateKeyBase58: (privateKeyBase58: string): string => Buffer.from(base58.decode(privateKeyBase58)).toString('hex'),\n  privateKeyJWK: (jwk: PrivateKeyJWK): string =>\n    keyto\n      .from(\n        {\n          ...jwk,\n          crv: 'K-256',\n        },\n        'jwk',\n      )\n      .toString('blk', 'private'),\n  privateKeyUint8Array: (privateKeyUint8Array: Uint8Array): string => Buffer.from(privateKeyUint8Array).toString('hex'),\n}\n\nexport const publicKeyUint8ArrayFrom = {\n  publicKeyBase58: (publicKeyBase58: string): Uint8Array => base58.decode(publicKeyBase58),\n  publicKeyHex: (publicKeyHex: string): Uint8Array => Uint8Array.from(Buffer.from(publicKeyHex, 'hex')),\n  publicKeyJWK: (jwk: PublicKeyJWK): Uint8Array => {\n    let asBuffer = Buffer.from(publicKeyHexFrom.publicKeyJWK(jwk), 'hex')\n    let padding = 32 - asBuffer.length\n    while (padding > 0) {\n      asBuffer = Buffer.concat([Buffer.from('00', 'hex'), asBuffer])\n      padding -= 1\n    }\n    return Uint8Array.from(asBuffer)\n  },\n  privateKeyUint8Array: (privateKeyUint8Array: Uint8Array): Uint8Array => secp256k1.publicKeyCreate(privateKeyUint8Array),\n}\n\nexport const privateKeyUint8ArrayFrom = {\n  privateKeyBase58: (privateKeyBase58: string): Uint8Array => base58.decode(privateKeyBase58),\n  privateKeyHex: (privateKeyHex: string): Uint8Array => Uint8Array.from(Buffer.from(privateKeyHex, 'hex')),\n  privateKeyJWK: (jwk: PrivateKeyJWK): Uint8Array => {\n    let asBuffer = Buffer.from(privateKeyHexFrom.privateKeyJWK(jwk), 'hex')\n    let padding = 32 - asBuffer.length\n    while (padding > 0) {\n      asBuffer = Buffer.concat([Buffer.from('00', 'hex'), asBuffer])\n      padding -= 1\n    }\n    return Uint8Array.from(asBuffer)\n  },\n}\n\nexport const publicKeyJWKFrom = {\n  publicKeyBase58: (publicKeybase58: string, kid: string): PublicKeyJWK =>\n    publicKeyJWKFrom.publicKeyHex(Buffer.from(base58.decode(publicKeybase58)).toString('hex'), kid),\n  publicKeyHex: (publicKeyHex: string, kid: string): PublicKeyJWK => {\n    const key =\n      publicKeyHex.length === compressedHexEncodedPublicKeyLength\n        ? Buffer.from(secp256k1.publicKeyConvert(Buffer.from(publicKeyHex, 'hex'), false)).toString('hex')\n        : publicKeyHex\n\n    return {\n      ...keyto.from(key, 'blk').toJwk('public'),\n      crv: 'secp256k1',\n      kid,\n    }\n  },\n  publicKeyUint8Array: (publicKeyUint8Array: Uint8Array, kid: string): PublicKeyJWK =>\n    publicKeyJWKFrom.publicKeyHex(Buffer.from(publicKeyUint8Array).toString('hex'), kid),\n  privateKeyJWK: (privateKeyJWK: PrivateKeyJWK): PublicKeyJWK => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { d, ...publicKeyJWK } = privateKeyJWK\n\n    return publicKeyJWK\n  },\n}\n\nexport const privateKeyJWKFrom = {\n  privateKeyBase58: (privateKeybase58: string, kid: string): PrivateKeyJWK =>\n    privateKeyJWKFrom.privateKeyHex(Buffer.from(base58.decode(privateKeybase58)).toString('hex'), kid),\n  privateKeyHex: (privateKeyHex: string, kid: string): PrivateKeyJWK => ({\n    ...keyto.from(privateKeyHex, 'blk').toJwk('private'),\n    crv: 'secp256k1',\n    kid,\n  }),\n  privateKeyUint8Array: (privateKeyUint8Array: Uint8Array, kid: string): PrivateKeyJWK =>\n    privateKeyJWKFrom.privateKeyHex(privateKeyHexFrom.privateKeyUint8Array(privateKeyUint8Array), kid),\n}\n"],"names":["SUITE_ID","sha256","data","createHash","update","digest","EcdsaSecp256k1VerificationKey2019","cryptoLd","LDKeyPair","constructor","publicKeyBase58","privateKeyBase58","options","type","publicKey","secp256k1","base58","this","TypeError","publicKeyHex","privateKeyHex","rest","Buffer","from","undefined","seed","compressed","keyPairOptions","Error","privateKey","Uint8Array","randomBytes","export","includeContext","exported","id","controller","revoked","SUITE_CONTEXT","signer","encodedHeader","base64url","encode","JSON","stringify","alg","b64","crit","payload","buffer","byteOffset","length","concat","signature","verifier","indexOf","encodedSignature","split","header","parse","decode","verified","suite","publicKeyHexFrom","toString","publicKeyJWK","jwk","publicKeyConvert","keyto","crv","publicKeyUint8Array","publicKeyCreate","privateKeyHexFrom","privateKeyJWK","privateKeyUint8Array","publicKeyUint8ArrayFrom","asBuffer","padding","privateKeyUint8ArrayFrom","publicKeyJWKFrom","publicKeybase58","kid","key","toJwk","privateKeyJWKFrom","privateKeybase58"],"mappings":"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"}