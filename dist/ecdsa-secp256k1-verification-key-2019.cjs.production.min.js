"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var r=e(require("base64url")),t=e(require("create-hash")),i=require("secp256k1"),o=e(i),f=e(require("randombytes")),a=e(require("crypto-ld")),y=require("base58-universal"),s=e(require("@trust/keyto"));const c="EcdsaSecp256k1VerificationKey2019",u=e=>t("sha256").update(e).digest();class n extends a.LDKeyPair{constructor({publicKeyBase58:e,privateKeyBase58:r,...t}){if(super(t),this.type=void 0,this.publicKeyBase58=void 0,this.privateKeyBase58=void 0,r&&!e){const e=i.publicKeyCreate(y.decode(r));this.publicKeyBase58=y.encode(e)}else this.publicKeyBase58=e;if(this.type=c,this.privateKeyBase58=r,!this.publicKeyBase58)throw new TypeError('The "publicKeyBase58" property is required.')}static from(e){if(e.publicKeyHex||e.privateKeyHex){const{publicKeyHex:r,privateKeyHex:t,...i}=e;return new n({...i,publicKeyBase58:r?y.encode(Buffer.from(r,"hex")):void 0,privateKeyBase58:t?y.encode(Buffer.from(t,"hex")):void 0})}return new n(e)}static async generate({seed:e,compressed:r,...t}){if(e&&!i.privateKeyVerify(e))throw new Error("Provided seed is not a valid private key");let o=e;for(;void 0===o||!i.privateKeyVerify(o);)o=new Uint8Array(f(32));const a=i.publicKeyCreate(o,r);return new n({publicKeyBase58:y.encode(a),privateKeyBase58:y.encode(o),...t})}export({publicKey:e=!1,privateKey:r=!1,includeContext:t=!1}={}){if(!e&&!r)throw new TypeError('export requires specifying either "publicKey" or "privateKey".');if(r&&!this.privateKeyBase58)throw new TypeError("No privateKey to export.");if(e&&!this.publicKeyBase58)throw new TypeError("No publicKey to export.");const i={type:this.type,id:this.id,controller:this.controller,revoked:this.revoked};return t&&(i["@context"]=n.SUITE_CONTEXT),r&&(i.privateKeyBase58=this.privateKeyBase58),e&&(i.publicKeyBase58=this.publicKeyBase58),i}signer(){const{privateKeyBase58:e}=this;return e?{async sign({data:t}){const o=r.encode(JSON.stringify({alg:"ES256K",b64:!1,crit:["b64"]})),f=Buffer.from(t.buffer,t.byteOffset,t.length),a=u(Buffer.from(Buffer.concat([Buffer.from(o+".","utf8"),Buffer.from(f.buffer,f.byteOffset,f.length)]))),{signature:s}=i.ecdsaSign(a,y.decode(e));return`${o}..${r.encode(Buffer.from(s))}`},id:this.id}:{async sign(){throw new Error("No private key to sign with.")},id:this.id}}verifier(){const{publicKeyBase58:e}=this;return e?{async verify({data:t,signature:o}){if(o.indexOf("..")<0)return!1;const[f,a]=o.split(".."),s=JSON.parse(r.decode(f));if("ES256K"!==s.alg||!1!==s.b64||!s.crit||!s.crit.length||"b64"!==s.crit[0])return!1;const c=Buffer.from(t.buffer,t.byteOffset,t.length),n=u(Buffer.from(Buffer.concat([Buffer.from(f+".","utf8"),Buffer.from(c.buffer,c.byteOffset,c.length)])));let p;try{p=i.ecdsaVerify(Buffer.from(r.decode(a,"hex"),"hex"),n,y.decode(e))}catch{p=!1}return p},id:this.id}:{async verify(){throw new Error("No public key to verify against")},id:this.id}}}n.suite=c,n.SUITE_CONTEXT="https://ns.did.ai/suites/secp256k1-2019/v1";const p={publicKeyBase58:e=>Buffer.from(y.decode(e)).toString("hex"),publicKeyJWK:e=>Buffer.from(o.publicKeyConvert(Buffer.from(s.from({...e,crv:"K-256"},"jwk").toString("blk","public"),"hex"),!0)).toString("hex"),publicKeyUint8Array:e=>Buffer.from(e).toString("hex"),privateKeyHex:e=>Buffer.from(o.publicKeyCreate(new Uint8Array(Buffer.from(e,"hex")))).toString("hex")},K={privateKeyBase58:e=>Buffer.from(y.decode(e)).toString("hex"),privateKeyJWK:e=>s.from({...e,crv:"K-256"},"jwk").toString("blk","private"),privateKeyUint8Array:e=>Buffer.from(e).toString("hex")},l={publicKeyBase58:e=>y.decode(e),publicKeyHex:e=>Uint8Array.from(Buffer.from(e,"hex")),publicKeyJWK:e=>{let r=Buffer.from(p.publicKeyJWK(e),"hex"),t=32-r.length;for(;t>0;)r=Buffer.concat([Buffer.from("00","hex"),r]),t-=1;return Uint8Array.from(r)},privateKeyUint8Array:e=>o.publicKeyCreate(e)},d={privateKeyBase58:e=>y.decode(e),privateKeyHex:e=>Uint8Array.from(Buffer.from(e,"hex")),privateKeyJWK:e=>{let r=Buffer.from(K.privateKeyJWK(e),"hex"),t=32-r.length;for(;t>0;)r=Buffer.concat([Buffer.from("00","hex"),r]),t-=1;return Uint8Array.from(r)}},h={publicKeyBase58:(e,r)=>h.publicKeyHex(Buffer.from(y.decode(e)).toString("hex"),r),publicKeyHex:(e,r)=>{const t=66===e.length?Buffer.from(o.publicKeyConvert(Buffer.from(e,"hex"),!1)).toString("hex"):e;return{...s.from(t,"blk").toJwk("public"),crv:"secp256k1",kid:r}},publicKeyUint8Array:(e,r)=>h.publicKeyHex(Buffer.from(e).toString("hex"),r),privateKeyJWK:e=>{const{...r}=e;return r}},v={privateKeyBase58:(e,r)=>v.privateKeyHex(Buffer.from(y.decode(e)).toString("hex"),r),privateKeyHex:(e,r)=>({...s.from(e,"blk").toJwk("private"),crv:"secp256k1",kid:r}),privateKeyUint8Array:(e,r)=>v.privateKeyHex(K.privateKeyUint8Array(e),r)};var b={__proto__:null,publicKeyHexFrom:p,privateKeyHexFrom:K,publicKeyUint8ArrayFrom:l,privateKeyUint8ArrayFrom:d,publicKeyJWKFrom:h,privateKeyJWKFrom:v};exports.EcdsaSecp256k1VerificationKey2019=n,exports.keyUtils=b;
//# sourceMappingURL=ecdsa-secp256k1-verification-key-2019.cjs.production.min.js.map
